#lang play
(print-only-errors)
(require "main.rkt")
;; Test sub-module.
;; See http://blog.racket-lang.org/2012/06/submodules.html

;this tests should never fail; these are tests for MiniScheme+
(module+ test
  (test (run '{+ 1 1}) 2)

  (test (run '{{fun {x y z} {+ x y z}} 1 2 3}) 6)

  (test (run '{< 1 2}) #t)

  (test (run '{local {{define x 1}}
                x}) 1)

  (test (run '{local {{define x 2}
                      {define y {local {{define x 1}} x}}}
                {+ x x}}) 4)

  ;; datatypes
  (test (run '{local {{datatype List {Empty} {Cons a b}}} {List? {Empty}}}) #t)

  (test (run '{local {{datatype List {Empty} {Cons a b}}} {Empty? {Empty}}}) #t)

  (test (run '{local {{datatype List {Empty} {Cons a b}}} {List? {Cons 1 2}}}) #t)

  (test (run '{local {{datatype List {Empty} {Cons a b}}} {Cons? {Cons 1 2}}}) #t)

  (test (run '{local {{datatype List {Empty} {Cons a b}}} {Empty? {Cons 1 2}}})
        #f)

  (test (run '{local {{datatype List {Empty} {Cons a b}}} {Empty? {Empty}}}) #t)

  (test (run '{local {{datatype List {Empty} {Cons a b}}} {Cons? {Empty}}})
        #f)

  ;; match
  (test (run '{match 1 {case 1 => 2}}) 2)

  (test (run '{match 2
                {case 1 => 2}
                {case 2 => 3}})
        3)

  (test (run '{match #t {case #t => 2}}) 2)

  (test (run '{match #f
                {case #t => 2}
                {case #f => 3}})
        3)

  (test (run '{local {{datatype Nat
                                {Zero}
                                {Succ n}}
                      {define pred {fun {n}
                                        {match n
                                          {case {Zero} => {Zero}}
                                          {case {Succ m} => m}}}}}
                {Succ? {pred {Succ {Succ {Zero}}}}}})
        #t)
  (test (run '{local {{datatype Nat
                                {Zero}
                                {Succ n}}
                      {define pred {fun {n}
                                        {match n
                                          {case {Zero} => {Zero}}
                                          {case {Succ m} => m}}}}}
                {Succ? {pred {Succ {Succ {Zero}}}}}}) #t))

;tests for extended MiniScheme+
;uncomment sanity tests when you are ready
#;(module+ sanity-tests
    (test (run '{local {{datatype Nat
                  {Zero}
                  {Succ n}}
                {define pred {fun {n}
                               {match n
                                 {case {Zero} => {Zero}}
                                 {case {Succ m} => m}}}}}
          {pred {Succ {Succ {Zero}}}}} "ppwu") "{Succ {Zero}}")

(test (run
 `{local ,stream-lib
          {local {,ones ,stream-take}
            {stream-take 11 ones}}} "pp") "{list 1 1 1 1 1 1 1 1 1 1 1}")

(test (run `{local ,stream-lib
          {local {,stream-zipWith ,fibs}
            {stream-take 10 fibs}}} "pp") "{list 1 1 2 3 5 8 13 21 34 55}")

(test (run `{local ,stream-lib
          {local {,ones ,stream-zipWith}
            {stream-take 10
                         {stream-zipWith
                          {fun {n m}
                               {+ n m}}
                          ones
                          ones}}}} "pp")  "{list 2 2 2 2 2 2 2 2 2 2}")
(test
(run `{local ,stream-lib
               {local {,stream-take ,merge-sort ,fibs ,stream-zipWith}
                 {stream-take 10 {merge-sort fibs fibs}}}} "pp")   "{list 1 1 1 1 2 2 3 3 5 5}"))

; ------------------------------------------------------------------------------------------------
; Test codigo agregado
; Rodrigo Urrea

;test for pretty-printing
; Ejemplo enunciado (structV con Succ y Zero)
(test (pretty-printing (structV 'Nat 'Succ (list (structV 'Nat 'Zero empty))))
"{Succ {Zero}}")
; (structV solo con Zero)
(test (pretty-printing (structV 'Nat 'Zero empty))
"{Zero}")
; otra struct, que tiene 2 elementos como values
(test (pretty-printing (structV 'List 'Cons (list 1 (structV 'List 'Empty '()))))
      "{Cons 1 {Empty}}")

;test for printing-pretty
; lista con una struct (struct recursiva)
(test (printing-pretty (list (structV 'Nat 'Zero empty))) " {Zero}")
; lista con disintos valores del lenguaje
(test (printing-pretty (list 'Nat 0 "twenty" #f))
      " Nat 0 twenty #f")
(test (printing-pretty
       (list 'Nat 0 "twenty" (structV 'Nat 'Zero empty)))
      " Nat 0 twenty {Zero}")
; lista vacia de valores
(test (printing-pretty '()) "")

;test flag "ppwu", con struct Nat
(test (run '{local {{datatype Nat 
                  {Zero} 
                  {Succ n}}
                {define pred {fun {n} 
                               {match n
                                 {case {Zero} => {Zero}}
                                 {case {Succ m} => m}}}}}
          {pred {Succ {Succ {Succ {Zero}}}}}} "ppwu")
      "{Succ {Succ {Zero}}}")
; Otro valor que no sea Struct
(test (run '{+ 1 1} "ppwu") 2)
(test (run '{or #t #f} "ppwu") #t)
(test (run '"hola" "ppwu") "hola")
; struct lista
(test (run '{list 1 2 3 4} "ppwu")
           "{Cons 1 {Cons 2 {Cons 3 {Cons 4 {Empty}}}}}")

;test creacion de lista
; lista vacia
(test (run '{Empty}) (structV 'List 'Empty '()))
; lista con elementos
(test (run '{Cons 10 {Empty}}) (structV 'List 'Cons (list 10 (structV 'List 'Empty '()))))
; cons pero que no es una lista
(test (run '{Cons 10 19}) (structV 'List 'Cons (list 10 19)))

;test funcs estructura listas
(test (run '{Empty? {Empty}}) #t)
(test (run '{List? {Empty}}) #t)
(test (run '{Cons? {Cons 1 {Empty}}}) #t)
; falla si le damos otra cosa
(test (run '{Empty? {Cons 1 {Empty}}}) #f)
(test (run '{local {{datatype Nat
                              {Zero}}}
           {List? {Zero}}}) #f)
(test (run '{Cons? {Empty}}) #f)

;test length
(test (run '{length {Empty}}) 0)
(test (run '{length {Cons 1 {Cons 2 {Cons 3 {Empty}}}}}) 3)
; si le damos a length un Cons que no es lista
(test/exn (run '{length {Cons 1 2}}) "Match failure")

;test parse-list
; lista vacia
(test (parse-list '{}) '{Empty})
; lista no vacia
(test (parse-list '{1 2 3 4}) '{Cons 1 {Cons 2 {Cons 3 {Cons 4 {Empty}}}}})
; lista con distintos valores
(test (parse-list '{"hola" #t}) '{Cons "hola" {Cons #t {Empty}}})

;test azucar sintactico list
; lista vacia
(test (run '{list}) (structV 'List 'Empty '()))
; lista no vacia
(test (run '{list 10}) (structV 'List 'Cons (list 10 (structV 'List 'Empty '()))))

;test azucar sintactico en match
; test lista no vacia
(test (run '{match {list {+ 1 1} 4 6}
              {case {Cons h r} => h}
              {case _ => 0}}) 2)
; test lista vacia
(test (run '{match {list}
              {case {Cons h r} => h}
              {case _ => 0}}) 0)
; test list en patron de match
(test (run '{match {list 2 {list 4 5} 6}
              {case {list a {list b c} d} => c}}) 5)
(test (run '{match {list {+ 1 1} 4 6}
              {case {list h r m} => h}
              {case _ => 0}}) 2)
(test (run '{match {list}
              {case {list h r} => h}
              {case _ => 0}}) 0)

;test pretty-printing-list
; struct nat (hace lo mismo que printing-pretty)
(test (pretty-printing-list
       (structV 'Nat 'Succ (list (structV 'Nat 'Zero empty))))
      "{Succ {Zero}}")
; struct list vacia
(test (pretty-printing-list (structV 'List 'Empty '())) "{list}")
; struct list no vacia
(test (pretty-printing-list
       (structV 'List 'Cons (list 1 (structV 'List 'Empty '()))))
       "{list 1}")

;test printing-pretty-list
; test struct list
(test (printing-pretty-list
       (list (structV 'List 'Empty '())))
      " {list}")
; test otra struct con vals
(test (printing-pretty-list
       (list (structV 'Nat 'Zero empty) 10))
      " {Zero} 10")
; test solo vals no structs
(test (printing-pretty-list
       (list 10 #f "hola"))
      " 10 #f hola")

;test pretty-list
; test lista vacia
(test (pretty-list (structV 'List 'Empty '()))
      "")
; test lista no vacia
(test (pretty-list (structV 'List 'Cons (list 10 (structV 'List 'Empty '()))))
      " 10")

;test flag "pp"
; test lista no vacia
(test (run '{list 1 4 6} "pp")
"{list 1 4 6}")
; test lista vacia
(test (run '{list} "pp")
"{list}")
; test otros valores
(test (run 2 "pp") 2)
(test (run '{local {{datatype Nat
                              {Zero}
                              {Succ n}}}
              {Succ {Succ {Zero}}}} "pp")
      "{Succ {Succ {Zero}}}")

;test delete-lazy
; lista con ids lazy
(test (delete-lazy '({lazy x} y z))
      '(x y z))
; lista sin ids lazt
(test (delete-lazy '(x y z))
      '(x y z))

;test strict
; strict elimina promesas
(test (strict (interp (parse '{{fun {{lazy x}} x} {+ 1 2}}) empty-env))
      3)
; sin strict queda la promesa
(test (interp (parse '{{fun {{lazy x}} x} {+ 1 2}}) empty-env)
      (exprV (prim-app '+ (list (num 1) (num 2))) empty-env (box 'undefined)))
; strict levante errores
(test/exn (strict (interp (parse '{{fun {{lazy x}} x} {/ 1 0}}) empty-env))
      "division by zero")
; strict deja igual todo lo que no sea promesas
(test (strict (interp (parse 10) empty-env))
      10)
(test (strict (structV 'Nat 'Zero '()))
      (structV 'Nat 'Zero '()))

;test extract-env
; se eliminan env de promesas
(test (extract-env (interp (parse '{{fun {{lazy x}} x} {+ 1 2}}) empty-env))
      (exprV-WE (prim-app '+ (list (num 1) (num 2)))))
; si no hay promesas se deja igual
(test (extract-env (interp (parse '{local {{datatype T
                                                     {C a}}}
                                     {C 1}}) empty-env))
      (structV 'T 'C (list 1)))

;test run lazy
; test lazy en fun
(test (run '{{fun {x  {lazy y}} x} 1 {/ 1 0}})
1)
; programa falla si no hay lazy
(test/exn (run '{{fun {x  y} x} 1 {/ 1 0}})
"division by zero")
; no hay lazy si se requiere evaluar
; (no se le puede dar promesa al usuario)
(test/exn (run '{{fun {x  {lazy y}} y} 1 {/ 1 0}})
"division by zero")
; fun lazy funcion en cualquier parte
(test (run '{local {{define x {list 0}}}
              {match x
                {case {Cons a b} => {{fun {{lazy y}} 0} {/ 1 a}}}}})
      0)
; test lazy en structs
; si hay var lazy, no se evalua a menos que sea necesario
(test (run '{local {{datatype T 
                  {C {lazy a}}}
                {define x {C {/ 1 0}}}}
          {T? x}})
#t)
; si se requiere, se evalua (con strict)
(test/exn (run '{local {{datatype T 
                  {C {lazy a}}}
                {define x {C {/ 1 0}}}}
          {match x
            {case {C a} => a}}})
"division by zero")
; tambien hay strict si se requiere hacer match
(test/exn (run '{local {{datatype T 
                        {C {lazy a} b}}
              {define x {C 2 {/ 88 0}}}}
        {match x
          {case {C z {C r t}} => z}
          {case {C h q} => h}}})
"division by zero")
; las flags pp y ppwu no imprimen promesas, las evaluan
(test (run '{local {{datatype T {C a {lazy b}}}
                {define x {C  0 {+ 1 2}}}}
               x} "pp")
"{C 0 3}")
(test (run '{local {{datatype T {C a {lazy b}}}
                {define x {C  0 {+ 1 2}}}}
               x} "ppwu")
"{C 0 3}")
(test (run '{local {{datatype T {C a {lazy b}}}
                {define x {C  0 {+ 1 2}}}}
               x})
(structV 'T 'C (list 0
                     (exprV-WE
                      (prim-app '+
                                (list (num 1)
                                      (num 2)))))))
; Listas no son lazy
(test/exn (run '{local {{datatype T 
                  {C {lazy a}}}
                {define x {C {/ 1 0}}}}
          {match x
            {case {C a} => {list a 10}}}})
      "division by zero")
; T es lazy
(test (run '{local {{datatype T 
                  {C {lazy a}}}
                {define x {C {/ 1 0}}}}
          {match x
            {case {C a} => {C a}}}})
      (structV 'T 'C (list (exprV-WE (id 'a)))))

;test stream-data
; se puede crear y su cola es lazy
(test (run `{local {,stream-data}
              {stream 10 {/ 1 0}}})
      (structV 'Stream 'stream
               (list 10
                     (exprV-WE
                      (prim-app '/ (list (num 1) (num 0)))))))

;test make-stream
; se puede crear stream
(test (run `{local {,stream-data ,make-stream}
              {Stream? {make-stream 1 {/ 1 0}}}})
      #t)
; se puede usar para generar un y de bash
(test (run `{local {,stream-data
                    ,make-stream
                    {define y {make-stream #t y}}}
              y})
      (structV 'Stream 'stream (list #t
                                     (exprV-WE (id 'tl)))))

;test ones
; se creo de buena manera
(test (run `{local {,stream-data ,make-stream ,ones}
           ones})
      (structV 'Stream 'stream (list 1
                                     (exprV-WE (id 'tl)))))

;test stream-hd
; funciona con ones
(test (run `{local {,stream-data ,make-stream ,stream-hd ,ones}
{stream-hd ones}}) 1)
; probamos que funciones con twos
(test (run `{local {,stream-data
                    ,make-stream
                    ,stream-hd
                    {define twos {make-stream 2 twos}}}
              {stream-hd twos}})
      2)      

;test stream-tl
; funciona con ones
(test (run `{local {,stream-data ,make-stream ,stream-hd ,stream-tl ,ones}
{stream-hd {stream-tl ones}}})
1)
; probamos la aplicacion sucesiva
(test (run `{local {,stream-data ,make-stream ,stream-hd ,stream-tl ,ones}
{stream-hd {stream-tl {stream-tl ones}}}})
1)

;test stream-take
; sacamos una cantidad
(test (run `{local ,stream-lib
          {local {,ones ,stream-take}
            {stream-take 10 ones}}} "pp")
"{list 1 1 1 1 1 1 1 1 1 1}")
; probamos sacar 0
(test (run `{local ,stream-lib
          {local {,ones ,stream-take
                    {define twos {make-stream 2 twos}}}
              {stream-take 0 twos}}} "pp")
      "{list}")

;test stream-zipWith
; probamos la suma entre 2 ones
(test (run `{local ,stream-lib
          {local {,ones ,stream-zipWith}
            {stream-take 10
                         {stream-zipWith
                          {fun {n m}
                               {+ n m}}
                          ones
                          ones}}}} "pp")
"{list 2 2 2 2 2 2 2 2 2 2}")

;test fibs
; verificamos si los numeros en fib son los de la sucesion de
; fibonacci
(test (run `{local ,stream-lib
          {local {,stream-zipWith ,fibs}
            {stream-take 10 fibs}}} "pp")
"{list 1 1 2 3 5 8 13 21 34 55}")

;test merge-sort
; verificamos si efectivamente ordena listas de numeros
(test (run `{local ,stream-lib
               {local {,stream-take ,merge-sort ,fibs ,stream-zipWith}
                 {stream-take 10 {merge-sort fibs fibs}}}} "pp")
"{list 1 1 1 1 2 2 3 3 5 5}")
; si le pasamos una lista de solo unos
(test (run `{local ,stream-lib
               {local {,stream-take ,merge-sort ,fibs ,stream-zipWith ,ones}
                 {stream-take 10 {merge-sort fibs ones}}}} "pp")
"{list 1 1 1 1 1 1 1 1 1 1}")