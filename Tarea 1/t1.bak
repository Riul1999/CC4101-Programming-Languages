#lang play
(print-only-errors #t)

#|
<expr>  ::= {<num>}
        | <id>
        | <bool>
        | {<unop> <expr>}
        | {<binop> <expr> <expr>}
        | {if <expr> <expr> <expr>}
        | {with {{<id> <expr>}*} <expr>}
        | {<id> <expr>*}
|#
(deftype Expr
  [num n]
  [id name]
  [bool b]
  [unop op1 c]
  [binop op2 l r]
  [if v t f]
  [with defs body]
  [app name es])

;<unop>  ::= ! | add1 | sub1
; lista de operadores unarios permitidos
(define unops (list '! 'add1 'sub1))

; is-unop?: Sym -> Bool
; recibe un simbolo e indica si dicho simbolo corresponde a un op unario
; de los definidos en la lista unops
(define (is-unop? x) (member x unops))

; parse-unop: Sym -> binop
; recibe un simbolo y entrega el unop asociado
(define (parse-unop un)
  (match un
    ['! not]
    ['add1 add1]
    ['sub1 sub1]))

;<binop>  ::= + | - | * | / | && | = | < | ...
; lista de operadores binarios permitidos
(define binops (list '+ '- '* '/ '&& '= '<))

; is-binop?: Sym -> Bool
; recibe un simbolo e indica si dicho simbolo corresponde a un op binario
; de los definidos en la lista binops
(define (is-binop? x) (member x binops))

; parse-binop: Sym -> binop
; recibe un simbolo y entrega el binop asociado
(define (parse-binop bin)
  (match bin
    ['+ +]
    ['- -]
    ['* *]
    ['/ /]
    ['&& (lambda (x y) (and x y))]
    ['= =]
    ['< <]))

; parse: Src -> Expr
; Convierte sintaxis concreta en sintaxis abstracta
(define (parse src)
  (match src
    [(? number?) (num src)]
    [(? symbol?) (id src)]
    [(? boolean?) (bool src)]
    [(list (? is-unop? op) s1) (unop (parse-unop op) (parse s1))]
    [(list (? is-binop? op) l r) (binop (parse-binop op) (parse l) (parse r))]
    [(list 'if val tr fa) (if (parse val) (parse tr) (parse fa))]
    [(list 'with (list rest ...) body) (with (parse-defs rest) (parse body))]
    [(list name exprs ...) (app (parse name) (parse-exprs exprs))]
    ))

; parse-defs: (Listof (Listof Src Src)) -> (Listof (Listof Expr Expr))
; Convierte la lista de definiciones provenientes del parseo de with en
; otra lista pero con las expresiones en sintaxis abstracta
(define (parse-defs defs)
  (match defs
    ['() '()]
    [(list (list name val) rest ...) (cons (list (parse name) (parse val)) (parse-defs rest))]))

(test (parse-defs '{}) '())
(test (parse-defs '{{x 10}}) (list (list (id 'x) (num 10))))
(test (parse-defs '{{x 10} {y #f}}) (list (list (id 'x) (num 10)) (list (id 'y) (bool #f))))

; parse-exprs: (Listof Src) -> (Listof Expr)
; Convierte la lista de expresiones provenientes del parseo de un aplicacion
; (ultimo caso de match) en otra lista con las expresiones en sintaxis abstracta
(define (parse-exprs expr)
  (match expr
    ['() '()]
    [(list e rest ...)  (cons (parse e) (parse-exprs rest))]))

(test (parse-exprs '{}) '())
(test (parse-exprs '{10}) (list (num 10)))
(test (parse-exprs '{#f 20}) (list (bool #f) (num 20)))

#|-----------------------------
Environment abstract data type: Env
empty-env  :: Env
extend-env :: Sym Val Env -> Env
env-lookup :: Sym Env -> Val (o error)

representation BNF:
<env> ::= (mtEnv)
        | (aEnv <id> <val> <env>)
|#

#|
<fundef>  ::= {define {<id> <id>*} <expr>}
|#

; interp :: Expr x Env -> Val

#|
<prog>  ::= {<fundef>* <expr>}
|#


#|
<unop>  ::= ! | add1 | sub1
|#

#|
<binop>  ::= + | - | * | / | && | = | < | ...
|#
